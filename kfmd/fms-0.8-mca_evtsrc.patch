diff -urN k2_os-kernel-2.6.28.10-8b9/arch/ia64/kernel/mca_drv.c k2_os-kernel-2.6.28.10-8b9-mca/arch/ia64/kernel/mca_drv.c
--- k2_os-kernel-2.6.28.10-8b9/arch/ia64/kernel/mca_drv.c	2010-07-09 02:34:42.000000000 +0800
+++ k2_os-kernel-2.6.28.10-8b9-mca/arch/ia64/kernel/mca_drv.c	2010-07-09 02:57:43.000000000 +0800
@@ -22,8 +22,8 @@
 #include <linux/smp.h>
 #include <linux/workqueue.h>
 #include <linux/mm.h>
-#include <linux/cpu.h>
-#include <linux/pageblock-flags.h>
+
+#include <linux/fm/protocol.h>
 
 #include <asm/delay.h>
 #include <asm/machvec.h>
@@ -267,31 +267,31 @@
 			LOG_INDEX_ADD_SECT_PTR(slidx->mem_dev_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_SEL_DEV_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 2;
 			LOG_INDEX_ADD_SECT_PTR(slidx->sel_dev_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_PCI_BUS_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 3;
 			LOG_INDEX_ADD_SECT_PTR(slidx->pci_bus_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 4;
 			LOG_INDEX_ADD_SECT_PTR(slidx->smbios_dev_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_PCI_COMP_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 5;
 			LOG_INDEX_ADD_SECT_PTR(slidx->pci_comp_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_SPECIFIC_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 6;
 			LOG_INDEX_ADD_SECT_PTR(slidx->plat_specific_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_HOST_CTLR_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 7;
 			LOG_INDEX_ADD_SECT_PTR(slidx->host_ctlr_err, sp);
 		} else if (!efi_guidcmp(sp->guid,
 				SAL_PLAT_BUS_ERR_SECT_GUID)) {
-			platform_err = 1;
+			platform_err = 8;
 			LOG_INDEX_ADD_SECT_PTR(slidx->plat_bus_err, sp);
 		} else {
 			LOG_INDEX_ADD_SECT_PTR(slidx->unsupported, sp);
@@ -561,6 +561,131 @@
 			 pmsa->pmsa_iip);
 }
 
+/*
+ * fm_external_bus_check
+ * @pbci:      pointer of pal_bus_check_info
+ *
+ * Return value:
+ *      none
+ */
+static void
+fm_external_bus_check(pal_bus_check_info_t *pbci, int status)
+{
+	unsigned int cpuid;
+	char *bus = NULL;
+	char *fault = NULL;
+	char fullclass[PATH_MAX];
+
+	/*
+	 * Infomation about external bus error, which pbci->bsi == 0.
+	 */
+	if (pbci->type == 1 || pbci->type == 3) /* 1: partial read;  3: full line(cpu) read */
+		bus = "memory";
+	else if (pbci->type == 9)		/* 9: I/O space read */
+		bus = "io";
+
+	if (status) {
+		fault = "rc";			/* Bus error recovered */
+	} else
+		fault = "uc";			/* Bus error not recovered (Fatal error)*/
+
+	cpuid = smp_processor_id();
+
+//      fm_sal_log_timestamp = time;
+
+	(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.bus_external_%s_%s",
+		FM_EREPORT_CLASS, bus, fault);
+
+	printk("cpumem_fm_event_post(%s)\n", fullclass);
+}
+
+/*
+ * fm_cache_check
+ * @peidx:      pointer of index of processor error section
+ *
+ * Return value:
+ *      none
+ */
+static void
+fm_cache_check(peidx_table_t *peidx, int status)
+{
+	int level;
+	unsigned int cpuid;
+	char *cache = NULL;
+	char *faultname = NULL;
+	char fullclass[PATH_MAX];
+
+	sal_log_mod_error_info_t *smei;
+	pal_cache_check_info_t *pcci;
+
+	smei = (sal_log_mod_error_info_t *)peidx_cache_check(peidx, 0);
+	pcci = (pal_cache_check_info_t *)&(smei->check_info);
+
+	/*
+	 * Infomation about cache error.
+	 */
+	level = pcci->level;
+
+	if (pcci->ic^pcci->dc)
+		cache = "";
+	else if (pcci->dc)
+		cache = "d";                    /* Cache: Data */
+	else if (pcci->ic)
+		cache = "i";                    /* Cache: Instruction */
+
+	if (status) {
+		faultname = "cache_rc";         /* Cache error recovered */
+	} else
+		faultname = "cache_uc";         /* Cache error not recovered (Fatal error)*/
+
+	cpuid = smp_processor_id();
+
+//      fm_sal_log_timestamp = time;
+
+	(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.l%d%s%s",
+		FM_EREPORT_CLASS, level, cache, faultname);
+
+	printk("cpumem_fm_event_post(%s)\n", fullclass);
+}
+
+/**
+ * fm_memory_device_check
+ * @slidx:      pointer of index of SAL error record
+ *
+ * Return value:
+ *  none
+ */
+
+static void
+fm_memory_device_check(slidx_table_t *slidx)
+{
+
+}
+	
+#if 0			/*< Fix Me !! >*/
+static void
+fm_memory_device_check(slidx_table_t *slidx)
+{
+	u64 target_identifier;
+	char *faultname;
+	char fullclass[PATH_MAX];
+
+	sal_log_mem_dev_err_info_t *mdei = (sal_log_mem_dev_err_info_t*)
+		slidx_first_entry(&slidx.mem_dev_err)->hdr;
+
+	if (mdei->valid.physical_addr) {
+		target_identifier = mdei->physical_addr;
+
+		faultname = "mem_page_uc";      /* Memory device error */
+		(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.quickpath.%s",
+			FM_EREPORT_CLASS, faultname);
+
+//  	cpumem_fm_event_post(fullclass);
+		printk("cpumem_fm_event_post(%s)\n", fullclass);
+	}
+}
+#endif
+
 /**
  * recover_from_platform_error - Recover from platform error.
  * @slidx:	pointer of index of SAL error record
@@ -573,8 +698,8 @@
  */
 
 static int
-recover_from_platform_error(slidx_table_t *slidx, peidx_table_t *peidx,
-			    pal_bus_check_info_t *pbci,
+recover_from_platform_error(int platform, slidx_table_t *slidx,
+	   			peidx_table_t *peidx, pal_bus_check_info_t *pbci,
 			    struct ia64_sal_os_state *sos)
 {
 	int status = 0;
@@ -588,6 +713,7 @@
 		case 9: /* I/O space read */
 			status = recover_from_read_error(slidx, peidx, pbci,
 							 sos);
+			fm_external_bus_check(pbci, status);
 			break;
 		case 0: /* unknown */
 		case 2: /* partial write */
@@ -604,9 +730,16 @@
 			break;
 		}
 	} else if (psp->cc && !psp->bc) {	/* Cache error */
-		status = recover_from_read_error(slidx, peidx, pbci, sos);
+		status = recover_from_read_error(slidx, peidx, pbci, sos);	/* try to recover Cache error */
+		fm_cache_check(peidx, status);	/* Cache Check for FM */
 	}
 
+	/*
+	 * Try to recover platform memory device error.
+	 */
+	if (platform == 1)
+		fm_memory_device_check(slidx);
+
 	return status;
 }
 
@@ -620,6 +753,12 @@
 static int
 recover_from_tlb_check(peidx_table_t *peidx)
 {
+	int level;
+	unsigned int cpuid;
+	char *tlb = NULL;
+	char *faultname = NULL;
+	char fullclass[PATH_MAX];
+
 	sal_log_mod_error_info_t *smei;
 	pal_tlb_check_info_t *ptci;
 
@@ -627,67 +766,139 @@
 	ptci = (pal_tlb_check_info_t *)&(smei->check_info);
 
 	/*
+	 * Infomation about TLB error.
+	 */
+	level = ptci->level;
+
+	if (((ptci->dtr || ptci->dtc) && (ptci->itr || ptci->itc)) ||
+			!(ptci->dtr && ptci->dtc && ptci->itr && ptci->itc))
+		tlb = "";
+	else if (ptci->dtr || ptci->dtc)
+		tlb = "d";			/* Data Translation Register/Cache */
+	else if (ptci->itr || ptci->itc)
+		tlb = "i";			/* Instruction Translation Register/Cache */
+
+	cpuid = smp_processor_id();
+
+//      fm_sal_log_timestamp = time;
+
+	/*
 	 * Look for signature of a duplicate TLB DTC entry, which is
 	 * a SW bug and always fatal.
 	 */
 	if (ptci->op == PAL_TLB_CHECK_OP_PURGE
-	    && !(ptci->itr || ptci->dtc || ptci->itc))
-		return fatal_mca("Duplicate TLB entry");
+	   && !(ptci->itr || ptci->dtc || ptci->itc)) {
+		faultname = "tlb_uc";           /* TLB error not recovered (Fatal error)*/
+		(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.l%d%s%s",
+			FM_EREPORT_CLASS, level, tlb, faultname);
+
+//		cpumem_fm_event_post(fullclass);
+		printk("cpumem_fm_event_post(%s)\n", fullclass);
+
+		return fatal_mca("Duplicate TLB entry");/* software misprograming causes illegal DTR purge */
+	} else {
+		faultname = "tlb_rc";           /* TLB error recovered */
+		(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.l%d%s%s",
+			FM_EREPORT_CLASS, level, tlb, faultname);
 
-	return mca_recovered("TLB check recovered");
+//		cpumem_fm_event_post(fullclass);
+		printk("cpumem_fm_event_post(%s)\n", fullclass);
+
+		return mca_recovered("TLB check recovered");
+	}
 }
 
-/**
- * recover_from_memory_error
- * @slidx:	pointer of index of SAL error record
- * @peidx:	pointer of index of processor error section
- * @pbci:	pointer of pal_bus_check_info
- * @sos:	pointer to hand off struct between SAL and OS
+/*
+ * recover_from_reg_file_check
+ * @peidx:      pointer of index of processor error section
  *
  * Return value:
- *	1 on Success / 0 on Failure
+ *      1 on Success / 0 on Failure
  */
-
 static int
-recover_from_memory_error(slidx_table_t *slidx,
-			     peidx_table_t *peidx, pal_bus_check_info_t *pbci,
-			     struct ia64_sal_os_state *sos)
+recover_from_reg_file_check(peidx_table_t *peidx)
 {
-	u64 target_identifier;
-        //pal_min_state_area_t *pmsa;
-	unsigned long pfn;
-	int ret;
+	return 0;
+}
 
-	//pal_processor_state_info_t *psp =
-	//	(pal_processor_state_info_t*)peidx_psp(peidx);
+/*
+ * fm_ib_check
+ * @pbci:      pointer of pal_bus_check_info
+ *
+ * Return value:
+ *      none
+ */
+static void
+fm_ib_check(pal_bus_check_info_t *pbci)
+{
+	unsigned int cpuid;
+	char *bus = NULL;
+	char *fault = NULL;
+	char fullclass[PATH_MAX];
 
 	/*
-	 * Processor recovery status must key off of the PAL recovery
-	 * status in the Processor State Parameter.
+	 * Infomation about internal bus error.
 	 */
+	if (pbci->type == 1 || pbci->type == 2 || pbci->type == 3
+	 || pbci->type == 4 || pbci->type == 5 || pbci->type == 8)
+		bus = "bus_internal_memory";
+	else if (pbci->type == 9 || pbci->type == 10)
+		bus = "bus_internal_io";
+	else
+		bus = "bus_internal";
 
-	/* Is target address valid? */
-        target_identifier = get_target_identifier(peidx);
-        if (!target_identifier)
-                return fatal_mca("target address not valid");
+	fault = "uc";				/* Bus error not recovered (Fatal error)*/
 
-	/* Is minstate valid? */
-        if (!peidx_bottom(peidx) || !(peidx_bottom(peidx)->valid.minstate))
-                return fatal_mca("minstate not valid");
+	cpuid = smp_processor_id();
 
-	pfn = PFN_DOWN(target_identifier);
-	
-	/* at least, alignment against pageblock is necessary */
-	if (!IS_ALIGNED(pfn, pageblock_nr_pages))
-                return -EINVAL;	
-
-	//ret = offline_pages( pfn, pfn, 120*HZ );
-	ret  = remove_memory( target_identifier, 0 );
-	if( ret )
-                return fatal_mca("memory error recover failed");
-	
-	return mca_recovered("memory error is corrected.");
+//      fm_sal_log_timestamp = time;
+
+	(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.%s_%s",
+		FM_EREPORT_CLASS, bus, fault);
+
+//	cpumem_fm_event_post(fullclass);
+	printk("cpumem_fm_event_post(%s)\n", fullclass);
 }
+
+/*
+ * fm_eb_check
+ * @pbci:      pointer of pal_bus_check_info
+ *
+ * Return value:
+ *      none
+ */
+static void
+fm_eb_check(pal_bus_check_info_t *pbci)
+{
+	unsigned int cpuid;
+	char *bus = NULL;
+	char *fault = NULL;
+	char fullclass[PATH_MAX];
+
+	/*
+	 * Infomation about external bus error, which pbci->bsi > 0.
+	 */
+	if (pbci->type == 1 || pbci->type == 2 || pbci->type == 3
+	 || pbci->type == 4 || pbci->type == 5 || pbci->type == 8) 
+		bus = "bus_external_memory";
+	else if (pbci->type == 9 || pbci->type == 10)
+		bus = "bus_external_io";
+	else
+		bus = "bus_external";
+
+	fault = "uc";                           /* Bus error not recovered (Fatal error)*/
+
+	cpuid = smp_processor_id();
+
+//      fm_sal_log_timestamp = time;
+
+	(void) snprintf(fullclass, sizeof(fullclass), "%s.cpu.intel.%s_%s",
+		FM_EREPORT_CLASS, bus, fault);
+
+//	cpumem_fm_event_post(fullclass);
+	printk("cpumem_fm_event_post(%s)\n", fullclass);
+}
+
 /**
  * recover_from_processor_error
  * @platform:	whether there are some platform error section or not
@@ -726,39 +937,16 @@
 		return fatal_mca("error not contained");
 
 	/*
-	 * Cannot handle more than one bus check.
+	 * Look for recoverable TLB check
 	 */
-	if (peidx_bus_check_num(peidx) > 1)
-		return fatal_mca("Too many bus checks");
-
-	if (pbci->eb && pbci->bsi > 0)
-		return fatal_mca("External bus check fatal status");
+	if (psp->tc && !(psp->cc || psp->bc || psp->rc || psp->uc))
+		return recover_from_tlb_check(peidx);
 
 	/*
-	 * internal bus check or register file check uarch check or cache 
-	 * and not bus check or tlb check
+	 * Look for recoverable Register File check
 	 */
-	if (pbci->ib || (psp->rc || psp->uc) ||(psp->cc && psp->bc == 0) || psp->tc)
-	{
-		unsigned int cpu;
-		ssize_t ret;
-		
-		cpu = smp_processor_id();
-		ret = cpu_down( cpu );
-		if( ret != 0 )
-			return fatal_mca("offline cpu failed\n");
-		else
-			return mca_recovered("machine check is corrected.");
-			
-	}
-
-	/*
-	 * cache and bus check ==> memory error
-	 */
-	if ( psp->cc && psp->bc ) 
-	{
-		return recover_from_memory_error(slidx, peidx, pbci, sos);
-	}
+	if (psp->rc && !(psp->cc || psp->bc || psp->tc || psp->uc))
+		return recover_from_reg_file_check(peidx);
 
 	/*
 	 * The cache check and bus check bits have four possible states
@@ -772,10 +960,28 @@
 		return fatal_mca("No cache or bus check");
 
 	/*
+	 * Cannot handle more than one bus check.
+	 */
+	if (peidx_bus_check_num(peidx) > 1)
+		return fatal_mca("Too many bus checks");
+
+	if (pbci->ib) {
+		fm_ib_check(pbci);
+
+		return fatal_mca("Internal Bus error");
+	}
+
+	if (pbci->eb && pbci->bsi > 0) {
+		fm_eb_check(pbci);
+
+		return fatal_mca("External bus check fatal status");
+	}
+
+	/*
 	 * This is a local MCA and estimated as a recoverable error.
 	 */
 	if (platform)
-		return recover_from_platform_error(slidx, peidx, pbci, sos);
+		return recover_from_platform_error(platform, slidx, peidx, pbci, sos);
 
 	/*
 	 * On account of strange SAL error record, we cannot recover.
diff -urN k2_os-kernel-2.6.28.10-8b9/include/linux/fm/protocol.h k2_os-kernel-2.6.28.10-8b9-mca/include/linux/fm/protocol.h
--- k2_os-kernel-2.6.28.10-8b9/include/linux/fm/protocol.h	1970-01-01 08:00:00.000000000 +0800
+++ k2_os-kernel-2.6.28.10-8b9-mca/include/linux/fm/protocol.h	2010-07-09 02:59:20.000000000 +0800
@@ -0,0 +1,32 @@
+/*
+ * protocol.h
+ *
+ * Copyright (C) 2009 Inspur, Inc.  All rights reserved.
+ * Copyright (C) 2009-2010 Fault Managment System Development Team
+ *
+ * Created on: Apr 07, 2010
+ *      Author: Inspur OS Team
+ *  
+ * Description:
+ *      protocol.h
+ */
+
+#ifndef _FM_PROTOCOL_H
+#define _FM_PROTOCOL_H
+
+/* FM common member names */
+#define FM_CLASS                        "class"
+#define FM_VERSION                      "version"
+
+/* FM event class values */
+#define FM_EREPORT_CLASS                "ereport"
+
+/* ereport version and payload member names */
+#define FM_EREPORT_VERS0                0
+#define FM_EREPORT_VERSION              FM_EREPORT_VERS0
+
+/* ereport payload member names */
+#define FM_EREPORT_DETECTOR             "detector"
+#define FM_EREPORT_ENA                  "ena"
+
+#endif  /* _FM_PROTOCOL_H */
Binary files k2_os-kernel-2.6.28.10-8b9/scripts/kconfig/conf and k2_os-kernel-2.6.28.10-8b9-mca/scripts/kconfig/conf differ
